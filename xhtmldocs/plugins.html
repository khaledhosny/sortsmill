<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org" />
  <!-- Created with AOLpress/2.0 -->
  <!-- AP: Created on: 10-Nov-2005 -->
  <!-- AP: Last modified: 18-Oct-2007 -->

  <title>Plugins in FontForge</title>
  <style type="text/css">
/*<![CDATA[*/
  span.c2 {color: red}
  h1.c1 {text-align: center}
  /*]]>*/
  </style>
</head>

<body>
  <h1 class="c1">Plugins in FontForge</h1>

  <p>FontForge supports a plugin mechanism for extending its
  functionality.</p>

  <p>Plugins are shared libraries that can be loaded at runtime.
  When fontforge starts up (actually, when it loads its
  preferences) it will automatically load all files that look like
  shared libraries and that live in the two directories:</p>

  <ul>
    <li><code>/usr/local/share/fontforge/plugins</code><br />
    (more precisely:
    <code>$(PREFIX)/share/fontforge/plugins</code>)</li>

    <li>
    <!-- FIXME: update this since we moved to XDG directory structure -->
    <code>~/.FontForge/plugins</code></li>
  </ul>

  <p>Most of what I once expected to do with plugins I now do with
  <a href="python.html#python-init-scripts">python scripts</a>.</p>

  <h2>Installing a one of my example plugins</h2>

  <p>Currently none of my pre-built packages contain any plugins.
  If you want to play with them you must <a href=
  "source-build.html">grab a source distribution</a>, build it, and
  install it. Having done that type the following:</p>

  <blockquote>
    <pre>
$ cd plugins
$ make install
</pre>
  </blockquote>

  <h2>Creating your own plugin</h2>

  <p>FontForge currently supports two types of plugins:</p>

  <ul>
    <li>plugins which add a 2byte encoding</li>

    <li>plugins which add a scripting command to the native
    scripting interface.</li>
  </ul>

  <p>(Actually I suppose there is a third type. When it loads a
  plugin FF calls an initialization routine. I suppose the plugin
  could just start running and doing things without ever returning
  to fontforge).</p>

  <p>I once expected to add</p>

  <ul>
    <li>plugins which add new menu items</li>
  </ul>

  <p>(but I did that in python instead).</p>

  <p>When FontForge loads a plugin it calls a routine <code>int
  FontForgeInit(void)</code>. This routine is responsible for
  registering the plugin with FontForge, and then returning to
  allow FontForge to continue. FontForge provides two registration
  routines:</p>

  <dl>
    <dt><code>AddEncoding(char *name,int (*enc_to_uni)(int), int
    (*uni_to_enc)(int))</code></dt>

    <dd>
      This registers a new encoding with the given name. You must
      supply two functions, one which converts from the encoding to
      unicode, and the other which converts from unicode to the
      encoding. <span class=
      "c2"><strong><big>NOTE:</big></strong></span> FontForge has a
      slightly unconventional definition of an encoding. It is not
      interested in byte streams, but in numbers. So if you have an
      8/16 encoding (like EUC or SJIS) then the encoding of a
      character will be a number between 0 and 65535. A single byte
      will be a number &lt;256, while a double byte character will
      be a number like 0xa1a1.

      <p>This will return 0 if it failed (if you tried to replace a
      built in encoding for example), 1 if it added the encoding, 2
      if it replaced a previous plugin with that name.</p>
    </dd>

    <dt><code>AddScriptingCommand(char *name, void
    (*UserScriptFunc)(Context *), int needs_font)</code></dt>

    <dd>
      This will add a new scripting command with the given name. If
      that name is called then UserScriptFunc will be invoked with
      a Context (which contains information like the arguments
      passed, the current font, and into which you set the return
      value (if any) of your function). The final argument
      indicates whether your command needs a font to be loaded or
      not. (the command Open() does not need a font loaded. The
      command Close() does).

      <p>This will return 0 if it failed (if you tried to replace a
      built in scripting command for example), 1 if it added the
      command, 2 if it replaced a previous plugin with that
      name.</p>
    </dd>
  </dl>

  <p>You may register more than one thing in from
  <code>FontForgeInit</code>. For example, many encodings have an
  EUC form and an ISO-2022 form and it makes sense for one plugin
  to handle both.</p>

  <p><code>FontForgeInit</code> should return 1 if it succeeds, and
  0 if it fails. If it fails FontForge will dlclose() the
  library.</p>

  <p>When you write your plugin you should include "plugins.h" from
  the fontforge directory.</p>

  <p>Look in the plugins subdirectory for an example on how to
  create, build &amp; install a plugin.</p>
</body>
</html>
