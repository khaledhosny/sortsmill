#! @GUILE@ \           -*- mode: bee; coding: utf-8 -*-
--no-auto-compile -s
!#

;; Copyright (C) 2012 Barry Schwartz
;; 
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3 of the License, or
;; (at your option) any later version.
;; 
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, see <http://www.gnu.org/licenses/>.

(use-modules
   (ice-9 popen)
   (ice-9 match)
   (ice-9 format)
   )

(define instruction-sources
   (list "@abs_top_builddir@/fontforge/fontforge_type_inspector"))

;; Collect the instructions into a list for repeated passes.
(define* (read-instructions port #:optional (lst '()))
   (let ((instruction (read port)))
      (if (eof-object? instruction)
          (reverse lst)
          (read-instructions port (cons instruction lst)))))

(define (read-instruction-sources sources)
   (match sources
      (() '())
      ((h . t)
       (let* ((port (open-input-pipe h))
              (some-instructions (read-instructions port)))
          (close-pipe port)
          (append some-instructions
             (read-instruction-sources t))))))

(define (write-declarations instructions)
   (for-each
      (lambda (instr)
         (match instr
            (('struct (? string? struct-name) (? integer? size))
             (format #t "type :: ~a\n" struct-name)
             (format #t "  type(c_ptr) :: ptr\n")
             (format #t "end type ~a\n" struct-name)
             (format #t "\n")
             (format #t "interface ~a\n" struct-name)
             (format #t "  module procedure c_intptr_t_to_~a\n" struct-name)
             (format #t "end interface ~a\n" struct-name)
             (format #t "\n")
             )
            (('field (? symbol? field-type) (? string? struct-name)
                (? string? field-name) (? integer? offset) (? integer? size))
             (format #t "interface get_~a\n" field-name)
             (format #t "  module procedure get_~a_~a\n" struct-name field-name)
             (format #t "end interface get_~a\n" field-name)
             (format #t "\n")
;             (format #t "interface set_~a\n" field-name)
;             (format #t "  module procedure set_~a_~a\n" struct-name field-name)
;             (format #t "end interface set_~a\n" field-name)
;             (format #t "\n")
             )
            (_ (lambda (_) *unspecified*))))
      instructions))

(define (write-definitions instructions)
   (for-each
      (lambda (instr)
         (match instr
            (('struct (? string? struct-name) (? integer? size))
             (format #t "function c_intptr_t_to_~a (p) result(q)\n" struct-name)
             (format #t "  integer(c_intptr_t), intent(in) :: p\n")
             (format #t "  type(~a) :: q\n" struct-name)
             (format #t "  q = ~a (.cptr. p)\n" struct-name)
             (format #t "end function c_intptr_t_to_~a\n" struct-name)
             (format #t "\n")
             )
            (('field (? symbol? field-type) (? string? struct-name)
                (? string? field-name) (? integer? offset) (? integer? size))
              (format #t "function get_~a_~a (p) result(q)\n" struct-name field-name)
              (format #t "  type(~a), intent(in) :: p\n" struct-name)
              (format #t "  ~a :: q\n" (get-field-type field-type size))
              (format #t "  ~a, pointer :: i\n" (get-internal-fortran-type field-type size))
              (format #t "  call c_f_pointer (~a, i)\n" (offset-by "p%ptr" offset))
              (convert-get-field field-type size "i" "q")
              (format #t "end function get_~a_~a\n" struct-name field-name)
              (format #t "\n")
;             (format #t "interface set_~a\n" field-name)
;             (format #t "  module procedure set_~a_~a\n" struct-name field-name)
;             (format #t "end interface set_~a\n" field-name)
;             (format #t "\n")
             )
            (_ (lambda (_) *unspecified*))))
      instructions))

(define (offset-by c-ptr offset)
   (if (zero? offset)
       (format #f "(~a)" c-ptr)
       (format #f "(~a .offsetby. ~d)" c-ptr offset)))

(define (get-internal-fortran-type field-type size)
   (match (cons field-type size)
      (('int . 1) "integer(c_int8_t)")
      (('int . 2) "integer(c_int16_t)")
      (('int . 4) "integer(c_int32_t)")
      (('int . 8) "integer(c_int64_t)")

      ;; Fortran does not have unsigned integers built in.
      (('uint . 1) "integer(c_int8_t)")
      (('uint . 2) "integer(c_int16_t)")
      (('uint . 4) "integer(c_int32_t)")
      (('uint . 8) "integer(c_int64_t)")

      (('bool . 1) "integer(c_int8_t)")
      (('bool . 2) "integer(c_int16_t)")
      (('bool . 4) "integer(c_int32_t)")
      (('bool . 8) "integer(c_int64_t)")

      (('* . 1) "integer(c_int8_t)")
      (('* . 2) "integer(c_int16_t)")
      (('* . 4) "integer(c_int32_t)")
      (('* . 8) "integer(c_int64_t)")
      ))

(define (get-field-kind field-type size)
   (match (cons field-type size)
      (('int . 1) "kind (1)")
      (('int . 2) "kind (1)")
      (('int . 4) "kind (1)")
      (('int . 8) "c_int64_t")

      ;; Fortran does not have unsigned integers built in.
      (('uint . 1) "kind (1)")
      (('uint . 2) "kind (1)")
      (('uint . 4) "selected_int_kind (10)")
      ;; FIXME: The following may not be supported by some compilers.
      ;; (GNU Fortran should support it as a 128-bit integer.)
      (('uint . 8) "selected_int_kind (20)")

      (('bool . _) "kind (.true.)")

      (('* . _) "c_intptr_t")
      ))

(define (get-field-type field-type size)
   (match field-type
      ('int (format #f "integer(~a)" (get-field-kind field-type size)))
      ('uint (format #f "integer(~a)" (get-field-kind field-type size)))
      ('bool (format #f "logical(~a)" (get-field-kind field-type size)))
      ('* (format #f "integer(~a)" (get-field-kind field-type size)))
      ))

(define (convert-get-field field-type size from-val to-val)
   (match field-type
      ('int
       (format #t "  ~a = int ((~a), kind=~a)\n"
          to-val from-val (get-field-kind field-type size))
       )
      ('uint
       (format #t "  if (0 <= ~a) then\n" from-val)
       (format #t "    ~a = int ((~a), kind=~a)\n"
          to-val from-val (get-field-kind field-type size))
       (format #t "  else\n")
       (format #t "    ! FIXME: The following assumes two's-complement arithmetic.\n")
       (format #t "    ~a = -(int (not (~a), kind=~a) + 1)\n"
          to-val from-val (get-field-kind field-type size))
       (format #t "  endif\n")
       )
      ('bool (format #t "  ~a = (~a /= 0)\n" to-val from-val))
      ('* (format #t "  ~a = .cintptr. (~a)\n" to-val from-val))
      ))

(let ((instructions (read-instruction-sources instruction-sources)))
   (format #t "! Generated by ~s\n" (car (command-line)))
   (format #t "\n")
   (format #t "module sortsmillff_internal_types\n")
   (format #t "use :: iso_c_binding\n")
   (format #t "implicit none\n")
   (format #t "\n")
   (format #t "interface\n")
   (format #t "\n")
   (format #t "  function c_intptr_t_to_c_ptr (p) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_intptr_t_to_c_ptr')\n")
   (format #t "    import\n")
   (format #t "    integer(c_intptr_t), value, intent(in) :: p\n")
   (format #t "    type(c_ptr) :: q\n")
   (format #t "  end function c_intptr_t_to_c_ptr\n")
   (format #t "\n")
   (format #t "  function c_intptr_t_to_c_funptr (p) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_intptr_t_to_c_funptr')\n")
   (format #t "    import\n")
   (format #t "    integer(c_intptr_t), value, intent(in) :: p\n")
   (format #t "    type(c_funptr) :: q\n")
   (format #t "  end function c_intptr_t_to_c_funptr\n")
   (format #t "\n")
   (format #t "  function c_ptr_to_c_intptr_t (p) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_ptr_to_c_intptr_t')\n")
   (format #t "    import\n")
   (format #t "    type(c_ptr), value, intent(in) :: p\n")
   (format #t "    integer(c_intptr_t) :: q\n")
   (format #t "  end function c_ptr_to_c_intptr_t\n")
   (format #t "\n")
   (format #t "  function c_funptr_to_c_intptr_t (p) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_funptr_to_c_intptr_t')\n")
   (format #t "    import\n")
   (format #t "    type(c_funptr), value, intent(in) :: p\n")
   (format #t "    integer(c_intptr_t) :: q\n")
   (format #t "  end function c_funptr_to_c_intptr_t\n")
   (format #t "\n")
   (format #t "  function c_ptr_plus_offset (p, i) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_ptr_plus_offset')\n")
   (format #t "    import\n")
   (format #t "    type(c_ptr), value, intent(in) :: p\n")
   (format #t "    integer(c_int), value, intent(in) :: i\n")
   (format #t "    type(c_ptr) :: q\n")
   (format #t "  end function c_ptr_plus_offset\n")
   (format #t "\n")
   (format #t "  function c_int8_t_to_c_intptr_t (p) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_int8_t_to_c_intptr_t')\n")
   (format #t "    import\n")
   (format #t "    integer(c_int8_t), value, intent(in) :: p\n")
   (format #t "    integer(c_intptr_t) :: q\n")
   (format #t "  end function c_int8_t_to_c_intptr_t\n")
   (format #t "\n")
   (format #t "  function c_int16_t_to_c_intptr_t (p) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_int16_t_to_c_intptr_t')\n")
   (format #t "    import\n")
   (format #t "    integer(c_int16_t), value, intent(in) :: p\n")
   (format #t "    integer(c_intptr_t) :: q\n")
   (format #t "  end function c_int16_t_to_c_intptr_t\n")
   (format #t "\n")
   (format #t "  function c_int32_t_to_c_intptr_t (p) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_int32_t_to_c_intptr_t')\n")
   (format #t "    import\n")
   (format #t "    integer(c_int32_t), value, intent(in) :: p\n")
   (format #t "    integer(c_intptr_t) :: q\n")
   (format #t "  end function c_int32_t_to_c_intptr_t\n")
   (format #t "\n")
   (format #t "  function c_int64_t_to_c_intptr_t (p) result(q) &\n")
   (format #t "      bind(c, name='_FF_FORTRAN_c_int64_t_to_c_intptr_t')\n")
   (format #t "    import\n")
   (format #t "    integer(c_int64_t), value, intent(in) :: p\n")
   (format #t "    integer(c_intptr_t) :: q\n")
   (format #t "  end function c_int64_t_to_c_intptr_t\n")
   (format #t "\n")
   (format #t "end interface\n")
   (format #t "\n")
   (format #t "interface operator(.cptr.)\n")
   (format #t "  module procedure c_intptr_t_to_c_ptr\n")
   (format #t "end interface operator(.cptr.)\n")
   (format #t "\n")
   (format #t "interface operator(.cfunptr.)\n")
   (format #t "  module procedure c_intptr_t_to_c_funptr\n")
   (format #t "end interface operator(.cfunptr.)\n")
   (format #t "\n")
   (format #t "interface operator(.cintptr.)\n")
   (format #t "  module procedure c_ptr_to_c_intptr_t\n")
   (format #t "  module procedure c_funptr_to_c_intptr_t\n")
   (format #t "  module procedure c_int8_t_to_c_intptr_t\n")
   (format #t "  module procedure c_int16_t_to_c_intptr_t\n")
   (format #t "  module procedure c_int32_t_to_c_intptr_t\n")
   (format #t "  module procedure c_int64_t_to_c_intptr_t\n")
   (format #t "end interface operator(.cintptr.)\n")
   (format #t "\n")
   (format #t "interface operator(.offsetby.)\n")
   (format #t "  module procedure c_ptr_plus_offset\n")
   (format #t "end interface operator(.offsetby.)\n")
   (format #t "\n")
   (write-declarations instructions)
   (format #t "contains\n")
   (format #t "\n")
   (write-definitions instructions)
   (format #t "end module sortsmillff_internal_types\n")
   )
