#! @GUILE@ \           -*- mode: bee; coding: utf-8 -*-
--no-auto-compile -s
!#

;; Copyright (C) 2012 Barry Schwartz
;; 
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3 of the License, or
;; (at your option) any later version.
;; 
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, see <http://www.gnu.org/licenses/>.

(use-modules
   (ice-9 popen)
   (ice-9 match)
   (ice-9 format)
   (rnrs bytevectors)
   )

(define instruction-sources
   (list "@abs_top_builddir@/fontforge/fontforge_type_inspector"))

(define sizeof-intptr_t @SIZEOF_INTPTR_T@)

(case sizeof-intptr_t
   ((4 8) (lambda () *unspecified*))
   (else
    (error "Only sizeof(intptr_t) equal to 4 or 8 is supported. Your sizeof(intptr_t) = ~d."
       sizeof-intptr_t)))

;; Collect the instructions into a list for repeated passes.
(define* (read-instructions port #:optional (lst '()))
   (let ((instruction (read port)))
      (if (eof-object? instruction)
          (reverse lst)
          (read-instructions port (cons instruction lst)))))

(define (read-instruction-sources sources)
   (match sources
      (() '())
      ((h . t)
       (let* ((port (open-input-pipe h))
              (some-instructions (read-instructions port)))
          (close-pipe port)
          (append some-instructions
             (read-instruction-sources t))))))

(define (write-declarations instructions)
   (for-each
      (lambda (instr)
         (match instr
            (('struct (? string? struct-name) (? integer? size))
             (format #t "type ~a\n" struct-name)
             (format #t "  ! Represent a C struct or union as a bytevector.\n")
             (format #t "  integer(c_int8_t), dimension(:), pointer :: bv\n")
             (format #t "end type ~a\n" struct-name)
             (format #t "\n")
             (format #t "! Constructors for ~a.\n" struct-name)
             (format #t "interface ~a\n" struct-name)
             (format #t "  module procedure c_ptr_to_~a\n" struct-name)
             (format #t "  module procedure c_intptr_t_to_~a\n" struct-name)
             (format #t "end interface ~a\n" struct-name)
             (format #t "\n")
             )
            (('field (? symbol? field-type) (? string? struct-name)
                (? string? field-name) (? integer? offset) (? integer? size))
             (format #t "interface get_~a\n" field-name)
             (format #t "  module procedure get_~a_~a\n" struct-name field-name)
             (format #t "end interface get_~a\n" field-name)
             (format #t "\n")
             (format #t "interface set_~a\n" field-name)
             (format #t "  module procedure set_~a_~a\n" struct-name field-name)
             (format #t "end interface set_~a\n" field-name)
             (format #t "\n")
             )
            (_ (lambda (_) *unspecified*))))
      instructions))

(define (write-definitions instructions)
   (for-each
      (lambda (instr)
         (match instr
            (('struct (? string? struct-name) (? integer? size))
             (begin
                (format #t "type(~a) function c_ptr_to_~a (p) result(q)\n"
                   struct-name struct-name)
                (format #t "  type(c_ptr), intent(in) :: p\n")
                (format #t "  call c_f_pointer (p, q%bv, [~d])\n" size)
                (format #t "end function c_ptr_to_~a\n" struct-name)
                (format #t "\n")
                (format #t "type(~a) function c_intptr_t_to_~a (p) result(q)\n"
                   struct-name struct-name)
                (format #t "  integer(c_intptr_t), intent(in) :: p\n")
                (format #t "  call c_f_pointer (.cptr. p, q%bv, [~d])\n" size)
                (format #t "end function c_intptr_t_to_~a\n" struct-name)
                (format #t "\n")
                ))
            (('field (? symbol? field-type) (? string? struct-name)
                (? string? field-name) (? integer? offset) (? integer? size))
             (begin
                (write-field-definitions field-type struct-name field-name offset size)
                ))
            (_ (lambda (_) *unspecified*))))
      instructions))

(define (write-field-definitions field-type struct-name field-name offset size)
   (match field-type
      ('int (write-int-field-definitions struct-name field-name offset size))
      ('uint (write-uint-field-definitions struct-name field-name offset size))
      ('bool (write-bool-field-definitions struct-name field-name offset size))
      ('* (write-pointer-field-definitions struct-name field-name offset size))))

(define (write-int-field-definitions struct-name field-name offset size)
   (write-get-int-field-definition struct-name field-name offset size)
   (write-set-int-field-definition struct-name field-name offset size))

(define (write-get-int-field-definition struct-name field-name offset size)
   (case size
      ((1 2 4)
       (begin
          (format #t "integer function get_~a_~a (p) result(q)\n" struct-name field-name)
          (format #t "  type(~a), intent(in) :: p\n" struct-name)
          (format #t "  q = int (transfer (p%bv(~d:~d), 1_c_int~d_t), kind (1))\n"
             (1+ offset) (+ offset size) (* 8 size))
          (format #t "end function get_~a_~a\n" struct-name field-name)
          (format #t "\n")))
      ((8)
       (begin
          (format #t "integer(c_int64_t) function get_~a_~a (p) result(q)\n" struct-name field-name)
          (format #t "  type(~a), intent(in) :: p\n" struct-name)
          (format #t "  q = transfer (p%bv(~d:~d), q)\n" (1+ offset) (+ offset size))
          (format #t "end function get_~a_~a\n" struct-name field-name)
          (format #t "\n")))))

(define (write-set-int-field-definition struct-name field-name offset size)
   (case size
      ((1 2 4)
       (begin
          (format #t "subroutine set_~a_~a (p, v)\n" struct-name field-name)
          (format #t "  type(~a), intent(inout) :: p\n" struct-name)
          (format #t "  integer, intent(in) :: v\n")
          (format #t "  p%bv(~d:~d) = transfer (int (v, 1_c_int~d_t), p%bv)\n"
             (1+ offset) (+ offset size) (* 8 size))
          (format #t "end subroutine set_~a_~a\n" struct-name field-name)
          (format #t "\n")))
      ((8)
       (begin
          (format #t "subroutine set_~a_~a (p, v)\n" struct-name field-name)
          (format #t "  type(~a), intent(inout) :: p\n" struct-name)
          (format #t "  integer(c_int64_t), intent(in) :: v\n")
          (format #t "  p%bv(~d:~d) = transfer (v, p%bv)\n" (1+ offset) (+ offset size))
          (format #t "end subroutine set_~a_~a\n" struct-name field-name)
          (format #t "\n")))))

(define (write-uint-field-definitions struct-name field-name offset size)
   (write-get-uint-field-definitions struct-name field-name offset size)
   (write-set-uint-field-definitions struct-name field-name offset size))
   
(define (write-get-uint-field-definitions struct-name field-name offset size)
   (format #t "! Unsigned ints are returned as INTEGER(KIND=C_INT64_T).\n")
   (when (= size 8)
      (format #t "!\n")
      (format #t "! WARNING: The returned 64-bit integer is SIGNED.\n")
      (format #t "! Unless the unsigned value is very large, this handling\n")
      (format #t "! likely is sufficient. However, in gfortran you can\n")
      (format #t "! get an actual unsigned integer by transferring the\n")
      (format #t "! data to an INTEGER(KIND=C_INT128_T).\n"))
   (format #t "integer(c_int64_t) function get_~a_~a (p) result(q)\n" struct-name field-name)
   (format #t "  type(~a), intent(in) :: p\n" struct-name)
   (format #t "  q = uint~d_to_uint64 (transfer (p%bv(~d:~d), 1_c_int~d_t))\n"
      (* 8 size) (1+ offset) (+ offset size) (* 8 size))
   (format #t "end function get_~a_~a\n" struct-name field-name)
   (format #t "\n"))

(define (write-set-uint-field-definitions struct-name field-name offset size)
   (format #t "subroutine set_~a_~a (p, v)\n" struct-name field-name)
   (format #t "  type(~a), intent(inout) :: p\n" struct-name)
   (format #t "  integer(c_int64_t), intent(in) :: v\n")
   (format #t "  p%bv(~d:~d) = transfer (uint64_to_uint~d (v), p%bv)\n"
      (1+ offset) (+ offset size) (* 8 size))
   (format #t "end subroutine set_~a_~a\n" struct-name field-name)
   (format #t "\n"))

(define (write-bool-field-definitions struct-name field-name offset size)
   (write-get-bool-field-definition struct-name field-name offset size)
   (write-set-bool-field-definition struct-name field-name offset size))

(define (write-get-bool-field-definition struct-name field-name offset size)
   (format #t "logical function get_~a_~a (p) result(q)\n" struct-name field-name)
   (format #t "  type(~a), intent(in) :: p\n" struct-name)
   (format #t "  q = (transfer (p%bv(~d:~d), 1_c_int~d_t) /= 0)\n"
      (1+ offset) (+ offset size) (* 8 size))
   (format #t "end function get_~a_~a\n" struct-name field-name)
   (format #t "\n"))

(define (write-set-bool-field-definition struct-name field-name offset size)
   (format #t "subroutine set_~a_~a (p, v)\n" struct-name field-name)
   (format #t "  type(~a), intent(inout) :: p\n" struct-name)
   (format #t "  logical, intent(in) :: v\n")
   (format #t "  integer(c_int8_t) :: i\n")
   (format #t "  if (v) then\n")
   (format #t "    i = 1_c_int8_t\n")
   (format #t "  else\n")
   (format #t "    i = 0_c_int8_t\n")
   (format #t "  endif\n")
   (format #t "  p%bv(~d:~d) = transfer (uint8_to_uint~d (i), p%bv)\n"
      (1+ offset) (+ offset size) (* 8 size))
   (format #t "end subroutine set_~a_~a\n" struct-name field-name)
   (format #t "\n"))

(define (write-pointer-field-definitions struct-name field-name offset size)
   (write-get-pointer-field-definition struct-name field-name offset size)
   (write-set-pointer-field-definition struct-name field-name offset size))

(define (write-get-pointer-field-definition struct-name field-name offset size)
   (format #t "integer(c_intptr_t) function get_~a_~a (p) result(q)\n" struct-name field-name)
   (format #t "  type(~a), intent(in) :: p\n" struct-name)
   (format #t "  q = uint~d_to_uint~d (transfer (p%bv(~d:~d), 1_c_int~d_t))\n"
      (* 8 size) (* 8 sizeof-intptr_t) (1+ offset) (+ offset size) (* 8 size))
   (format #t "end function get_~a_~a\n" struct-name field-name)
   (format #t "\n"))

(define (write-set-pointer-field-definition struct-name field-name offset size)
   (format #t "subroutine set_~a_~a (p, v)\n" struct-name field-name)
   (format #t "  type(~a), intent(inout) :: p\n" struct-name)
   (format #t "  integer(c_intptr_t), intent(in) :: v\n")
   (format #t "  p%bv(~d:~d) = transfer (uint~d_to_uint~d (v), p%bv)\n"
      (1+ offset) (+ offset size) (* 8 sizeof-intptr_t) (* 8 size))
   (format #t "end subroutine set_~a_~a\n" struct-name field-name)
   (format #t "\n"))

(define (write-unsigned-int-conversion from-size to-size)
   (format #t "integer(c_int~d_t) function uint~d_to_uint~d (i) result(j)\n"
      (* 8 to-size) (* 8 from-size) (* 8 to-size))
   (format #t "  integer(c_int~d_t), intent(in) :: i\n" (* 8 from-size))
   (cond
      ((= from-size to-size) (format #t "  j = i\n"))
      ((< from-size to-size)
       (format #t "  integer(c_int8_t), dimension(~d) :: temp\n" to-size)
       (format #t "  temp = transfer (0_c_int~d_t, temp)\n" (* 8 to-size) (* 8 to-size))
       (if (eq? (native-endianness) 'little)
           (format #t "  temp(:~d) = transfer (i, temp)\n" from-size)
           ;;
           ;; FIXME: This will need testing on a big-endian
           ;; architecture.
           (format #t "  temp(~d:) = transfer (i, temp)\n" (1+ (- to-size from-size))))
       (format #t "  j = transfer (temp, j)\n"))
      (else
       (format #t "  integer(c_int8_t), dimension(~d) :: temp\n" from-size)
       (format #t "  temp = transfer (i, temp)\n")
       (if (eq? (native-endianness) 'little)
           (format #t "  j = transfer (temp(:~d), j)\n" to-size)
           ;;
           ;; FIXME: This will need testing on a big-endian
           ;; architecture.
           (format #t "  j = transfer (temp(~d:), j)\n" (1+ (- from-size to-size))))))
   (format #t "end function uint~d_to_uint~d\n" (* 8 from-size) (* 8 to-size))
   (format #t "\n"))

(let ((instructions (read-instruction-sources instruction-sources)))
   (format #t "! Generated by ~s\n" (car (command-line)))
   (format #t "\n")
   (format #t "module sortsmillff_internal_types\n")
   (format #t "use :: iso_c_binding\n")
   (format #t "implicit none\n")
   (format #t "\n")
   (format #t "interface\n")
   (format #t "\n")
   (format #t "  type(c_ptr) function c_intptr_t_to_c_ptr (p) &\n")
   (format #t "        bind(c, name='_FF_FORTRAN_c_intptr_t_to_c_ptr')\n")
   (format #t "    import\n")
   (format #t "    integer(c_intptr_t), value, intent(in) :: p\n")
   (format #t "  end function c_intptr_t_to_c_ptr\n")
   (format #t "\n")
   (format #t "  type(c_funptr) function c_intptr_t_to_c_funptr (p) &\n")
   (format #t "        bind(c, name='_FF_FORTRAN_c_intptr_t_to_c_funptr')\n")
   (format #t "    import\n")
   (format #t "    integer(c_intptr_t), value, intent(in) :: p\n")
   (format #t "  end function c_intptr_t_to_c_funptr\n")
   (format #t "\n")
   (format #t "  integer(c_intptr_t) function c_ptr_to_c_intptr_t (p) &\n")
   (format #t "        bind(c, name='_FF_FORTRAN_c_ptr_to_c_intptr_t')\n")
   (format #t "    import\n")
   (format #t "    type(c_ptr), value, intent(in) :: p\n")
   (format #t "  end function c_ptr_to_c_intptr_t\n")
   (format #t "\n")
   (format #t "  integer(c_intptr_t) function c_funptr_to_c_intptr_t (p) &\n")
   (format #t "        bind(c, name='_FF_FORTRAN_c_funptr_to_c_intptr_t')\n")
   (format #t "    import\n")
   (format #t "    type(c_funptr), value, intent(in) :: p\n")
   (format #t "  end function c_funptr_to_c_intptr_t\n")
   (format #t "\n")
   (format #t "end interface\n")
   (format #t "\n")
   (format #t "interface operator(.cptr.)\n")
   (format #t "  module procedure c_intptr_t_to_c_ptr\n")
   (format #t "end interface operator(.cptr.)\n")
   (format #t "\n")
   (format #t "interface operator(.cfunptr.)\n")
   (format #t "  module procedure c_intptr_t_to_c_funptr\n")
   (format #t "end interface operator(.cfunptr.)\n")
   (format #t "\n")
   (format #t "interface operator(.cintptr.)\n")
   (format #t "  module procedure c_ptr_to_c_intptr_t\n")
   (format #t "  module procedure c_funptr_to_c_intptr_t\n")
   (format #t "end interface operator(.cintptr.)\n")
   (format #t "\n")
   (write-declarations instructions)
   (format #t "contains\n")
   (format #t "\n")
   (write-unsigned-int-conversion 1 1)
   (write-unsigned-int-conversion 1 2)
   (write-unsigned-int-conversion 1 4)
   (write-unsigned-int-conversion 2 4)
   (write-unsigned-int-conversion 4 4)
   (write-unsigned-int-conversion 8 4)
   (write-unsigned-int-conversion 1 8)
   (write-unsigned-int-conversion 2 8)
   (write-unsigned-int-conversion 4 8)
   (write-unsigned-int-conversion 8 8)
   (write-definitions instructions)
   (format #t "end module sortsmillff_internal_types\n")
   )
