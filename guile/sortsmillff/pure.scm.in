;; -*- mode: scheme; coding: utf-8 -*-

;; Copyright (C) 2012 Barry Schwartz
;; 
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3 of the License, or
;; (at your option) any later version.
;; 
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, see <http://www.gnu.org/licenses/>.

(define-module (sortsmillff pure))

(import (sortsmillff i18n)
        (rnrs)
        (srfi :1)
        (ice-9 match)
        (ice-9 format)
        (system foreign))

(export if-fontforge-has-pure-api)

(define-syntax if-fontforge-has-pure-api
  (lambda (x)
    (match '@i_do_have_pure_api@
           ('yes
            (syntax-case x ()
              ((_ e e* ...) #'(begin e e* ...))))
           ('no
            (syntax-case x ()
              ((_ _ _ ...) #'*unspecified*))))))

(if-fontforge-has-pure-api

 (export pure-dll

         pure-op-infix
         pure-op-infixl
         pure-op-infixr
         pure-op-prefix
         pure-op-postfix
         pure-op-nullary
         pure-prec-max
         pure-nprec-max
         pure-fixity-max

         string->symbol-pure-expr   ; Creates the symbol if necessary.
         string->symbol-pure-expr-or-f  ; Returns #f if the symbol
                                        ; does not exist.
         symbol-pure-expr->string
         pure-closing-symbol
         pure-fixity
         eval-pure-symbol

         pure-expr?
         pointer->pure-expr
         pure-expr->pointer

         number->pure-expr
         pure-expr->number
         pure-expr-is-number?

         integer->pure-expr
         small-integer->pure-expr
         big-integer->pure-expr
         pure-expr->integer
         pure-expr->small-integer
         pure-expr->big-integer
         pure-expr-is-integer?
         pure-expr-is-small-integer?
         pure-expr-is-big-integer?

         rational->pure-expr
         pure-expr->rational
         pure-expr-is-rational?

         inexact->pure-expr
         flonum->pure-expr
         pure-expr->inexact
         pure-expr->flonum
         pure-expr-is-inexact?
         pure-expr-is-flonum?

         complex->pure-expr
         pure-expr->complex
         pure-expr-is-complex?

         pointer->pointer-pure-expr
         pointer-pure-expr->pointer

         string->pure-expr
         pure-expr->string
         pure-expr-is-string?

         pure-interp?
         pointer->pure-interp
         pure-interp->pointer
         pure-create-interp
         pure-delete-interp
         pure-switch-interp
         pure-current-interp
         )

 (define pure-dll
   (dynamic-link "libguile-sortsmillff_pure"))

 (dynamic-call "init_guile_sortsmillff_pure" pure-dll)

 (define pure-op-infix 0)
 (define pure-op-infixl 1)
 (define pure-op-infixr 2)
 (define pure-op-prefix 3)
 (define pure-op-postfix 4)
 (define pure-op-nullary 5)
 (define pure-prec-max 16777216)
 (define pure-nprec-max 167772160)
 (define-syntax pure-fixity-max
   (identifier-syntax pure-nprec-max))

 (define string->symbol-pure-expr
   (let ((proc (pointer->procedure
                int32 (dynamic-func "pure_sym" pure-dll)
                `(*))))
     (lambda (s)
       (pure-quoted-symbol (proc (string->pointer s "UTF-8"))))))

 (define string->symbol-pure-expr-or-f
   (let ((proc (pointer->procedure
                int32 (dynamic-func "pure_getsym" pure-dll)
                `(*))))
     (lambda (s)
       (let ((sym (proc (string->pointer s "UTF-8"))))
         (if (zero? sym) #f (pure-quoted-symbol sym))))))

 (define symbol-pure-expr->small-integer
   (lambda (caller x)
   (cond
    ((symbol-pure-expr->small-integer-or-f x))
    (else
     (error caller
            (_ "the Pure expression is not a symbol")
            x)))))
            
 (define symbol-pure-expr->string
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_sym_pname" pure-dll)
                `(,int32))))
     (lambda (x)
       (let ((sym (symbol-pure-expr->small-integer
                   'symbol-pure-expr->string x)))
         (pointer->string (proc sym) -1 "UTF-8")))))
 
 (define pure-closing-symbol
   (let ((proc (pointer->procedure
                int32 (dynamic-func "pure_sym_other" pure-dll)
                `(,int32))))
     (lambda (x)
       (let* ((sym (symbol-pure-expr->small-integer
                    'pure-closing-symbol x))
              (other (proc sym)))
         (if (zero? other) #f (pure-quoted-symbol other))))))

 (define pure-fixity
   (let ((proc (pointer->procedure
                int32 (dynamic-func "pure_sym_nprec" pure-dll)
                `(,int32))))
     (lambda (x)
       (let ((sym (symbol-pure-expr->small-integer 'pure-fixity x)))
         (proc sym)))))

(define eval-pure-symbol
  (lambda (string)
    (let ((result-pair (private:eval-pure-symbol string)))
      (if result-pair
          (match-lambda
           ((result . pure-exception)
            (if pure-exception
                (throw 'pure-exception pure-exception)
                result)))
          (error 'eval-pure-symbol
                 (_ "the Pure symbol does not exist") string)))))

;;;;;;;
;;;;;;; FIXME: Actually print the Pure expression.
;;;;;;;
 (define-wrapped-pointer-type pure-expr
   pure-expr?
   private:pointer->pure-expr pure-expr->pointer
   (lambda (expr port)
     (format port "#<pure-expr 0x~x>"
             (pointer-address (pure-expr->pointer expr)))))

 (define pointer->pure-expr
   ;; @var{pointer->pure-expr} sets up reference counting for the Pure
   ;; garbage collector, then wraps the pointer as a @var{pure-expr}
   ;; object.
   (lambda (p)
     (private:pointer->pure-expr (scm-pure-new p))))

 (define procedure:pure-expr->pointer
   ;; Wrap the syntax transformer @var{pure-expr->pointer} in a
   ;; procedure, so C code can use it.
   (lambda (x) (pure-expr->pointer x)))

 (define number->pure-expr
   (lambda (n)
     (cond
      ((inexact? n) (if (real? n)
                        (inexact->pure-expr n)
                        (complex->pure-expr n)))
      ((integer? n) (integer->pure-expr n))
      ((rational? n) (rational->pure-expr n))
      (else (error 'number->pure-expr
                   (_ "not a number") x)))))

 (define pure-expr->number
   (lambda (x)
     (cond
      ((pure-expr->small-integer-or-f x))
      ((pure-expr->inexact-or-f x))
      ((pure-expr->big-integer-or-f x))
      ((pure-expr->rational-or-f x))
      ((pure-expr->complex-or-f x))
      (else
       (error 'pure-expr->number
              (_ "the Pure expression is not a number")
              x)))))

 (define pure-expr-is-number?
   (lambda (x)
     (cond
      ((pure-expr-is-integer? x) #t)
      ((pure-expr-is-inexact? x) #t)
      ((pure-expr-is-rational? x) #t)
      ((pure-expr-is-complex? x) #t)
      (else #f))))

 (define integer->pure-expr
   (lambda (n)
     (if (and (<= -2147483648 n) (<= n 2147483647))
         (small-integer->pure-expr n)
         (big-integer->pure-expr n))))

 (define small-integer->pure-expr
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_int" pure-dll)
                `(,int32))))
     (compose pointer->pure-expr proc)))

 (define pure-expr->integer
   (lambda (x)
     (cond
      ((pure-expr->small-integer-or-f x))
      ((pure-expr->big-integer-or-f x))
      (else
       (error
        'pure-expr->integer
        (_ "the Pure expression is not an integer")
        x)))))

 (define pure-expr->small-integer
   (lambda (x)
     (cond
      ((pure-expr->small-integer-or-f x))
      (else
       (error
        'pure-expr->small-integer
        (_ "the Pure expression is not an integer in the range -2147483648 to 2147483647")
        x)))))

 (define pure-expr->big-integer
   (lambda (x)
     (cond
      ((pure-expr->big-integer-or-f x))
      (else
       (error
        'pure-expr->big-integer
        (_ "the Pure expression is not an integer outside the range -2147483648 to 2147483647")
        x)))))

 (define pure-expr-is-integer?
   (lambda (n)
     (cond
      ((pure-expr-is-small-integer? n) #t)
      ((pure-expr-is-big-integer? n) #t)
      (else #f))))

 (define pure-expr-is-small-integer?
   (compose not not pure-expr->small-integer-or-f))

 (define pure-expr-is-big-integer?
   (compose not not pure-expr->big-integer-or-f))

 (define pure-expr->rational
   (lambda (x)
     (cond
      ((pure-expr->rational-or-f x))
      (else
       (error
        'pure-expr->rational
        (_ "the Pure expression is not a rational number")
        x)))))

 (define pure-expr-is-rational?
   (compose not not pure-expr->rational-or-f))

 (define inexact->pure-expr
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_double" pure-dll)
                `(,double))))
     (compose pointer->pure-expr proc)))

 (define-syntax flonum->pure-expr
   (identifier-syntax inexact->pure-expr))

 (define pure-expr->inexact
   (lambda (x)
     (cond
      ((pure-expr->inexact-or-f x))
      (else
       (error
        'pure-expr->inexact
        (_ "the Pure expression is not a floating point number")
        x)))))

 (define-syntax pure-expr->flonum
   (identifier-syntax pure-expr->inexact))

 (define pure-expr-is-inexact?
   (compose not not pure-expr->inexact-or-f))

 (define-syntax pure-expr-is-flonum?
   (identifier-syntax pure-expr-is-inexact?))

 (define pure-expr->complex
   (lambda (x)
     (cond
      ((pure-expr->complex-or-f x))
      (else
       (error 'pure-expr->complex
              (_ "the Pure expression is not a complex number")
              x)))))

 (define pure-expr-is-complex?
   (compose not not pure-expr->complex-or-f))

 (define pointer->pointer-pure-expr
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_pointer" pure-dll)
                `(*))))
     (compose pointer->pure-expr proc)))

 (define pointer-pure-expr->pointer
   (lambda (x)
     (cond
      ((pointer-pure-expr->pointer-or-f x))
      (else
       (error 'pure-expr->complex
              (_ "the Pure expression is not a pointer")
              x)))))

 (define string->pure-expr
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_string_dup" pure-dll)
                `(*))))
     (lambda (s)
       (pointer->pure-expr (proc (string->pointer s "UTF-8"))))))

 (define pure-expr->string
   (lambda (x)
     (cond
      ((pure-expr->string-or-f x))
      (else
       (error 'pure-expr->complex
              (_ "the Pure expression is not a string")
              x)))))

 (define-wrapped-pointer-type pure-interp
   pure-interp? pointer->pure-interp pure-interp->pointer
   (lambda (interp port)
     (format port "#<pure-interp 0x~x>"
             (pointer-address (pure-interp->pointer interp)))))

 (define pure-create-interp
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_create_interp" pure-dll)
                `(,int *))))
     (lambda (args)
       (let ((argc (length args))
             (argv (string-list->argv args)))
         (pointer->pure-interp
          (proc argc (bytevector->pointer argv)))))))

 (define pure-delete-interp
   (let ((proc (pointer->procedure
                void (dynamic-func "pure_delete_interp" pure-dll)
                `(*))))
     (compose proc pure-interp->pointer)))

 (define pure-switch-interp
   (let ((proc (pointer->procedure
                void (dynamic-func "pure_switch_interp" pure-dll)
                `(*))))
     (compose proc pure-interp->pointer)))

 (define pure-current-interp
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_current_interp" pure-dll)
                `())))
     (compose pointer->pure-interp proc)))

 (define pure-quoted-symbol
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_quoted_symbol" pure-dll)
                `(,int32))))
     (compose pointer->pure-expr proc)))

 ;; FIXME: This could be useful more generally.
 (define (string-list->argv args)
   (let* ((n (length args))
          (pointer-size (sizeof '*))
          (num-bytes (* pointer-size (+ 1 n)))
          (argv (make-bytevector num-bytes 0)))
     (for-each
      (match-lambda
       ((i s) (bytevector-pointer-set! argv (* i pointer-size)
                                       (string->pointer s))))
      (zip (iota n) args))
     argv
     ))

 ;; FIXME: Put this somewhere reusable.
 (define-syntax bytevector-pointer-set!
   (lambda (x)
     (unless (or (= 4 (sizeof '*)) (= 8 (sizeof '*)))
       (error 'bytevector-pointer-set!
              "cannot handle pointer sizes other than 4 or 8"
              (sizeof '*)))
     (syntax-case x ()
       ((_ bv offset p)
        (case (sizeof '*)
          ((4) #'(bytevector-u32-native-set! bv offset (pointer-address p)))
          ((8) #'(bytevector-u64-native-set! bv offset (pointer-address p)))
          )))))

 ) ;; end of if-fontforge-has-pure-api
