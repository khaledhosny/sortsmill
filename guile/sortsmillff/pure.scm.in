;; -*- mode: scheme; coding: utf-8 -*-

;; Copyright (C) 2012 Barry Schwartz
;; 
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3 of the License, or
;; (at your option) any later version.
;; 
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, see <http://www.gnu.org/licenses/>.

(define-module (sortsmillff pure))

(import (sortsmillff i18n)
        (rnrs)
        (srfi :1)
        (ice-9 match)
        (ice-9 format)
        (system foreign))

(export if-fontforge-has-pure-api)

(define-syntax if-fontforge-has-pure-api
  (lambda (x)
    (match '@i_do_have_pure_api@
           ('yes
            (syntax-case x ()
              ((_ e e* ...) #'(begin e e* ...))))
           ('no
            (syntax-case x ()
              ((_ _ _ ...) #'*unspecified*))))))

(if-fontforge-has-pure-api

 (export pure-dll

         pure-op_infix
         pure-op_infixl
         pure-op_infixr
         pure-op_prefix
         pure-op_postfix
         pure-op_nullary
         pure-prec_max
         pure-nprec_max

         pure-sym
         pure-getsym
         pure-sym-pname
         pure-sym-other
         pure-sym-nprec

         pure-expr?
         pointer->pure-expr
         pure-expr->pointer

         pure-symbol
         pure-symbolx
         pure-quoted-symbol

         number->pure-expr
         pure-expr->number
         pure-expr-is-number?

         integer->pure-expr
         small-integer->pure-expr
         big-integer->pure-expr
         pure-expr->integer
         pure-expr->small-integer
         pure-expr->big-integer
         pure-expr-is-integer?
         pure-expr-is-small-integer?
         pure-expr-is-big-integer?

         rational->pure-expr
         pure-expr->rational
         pure-expr-is-rational?

         inexact->pure-expr
         flonum->pure-expr
         pure-expr->inexact
         pure-expr->flonum
         pure-expr-is-inexact?
         pure-expr-is-flonum?

         complex->pure-expr
         pure-expr->complex
         pure-expr-is-complex?

         pointer->pointer-pure-expr
         pointer-pure-expr->pointer

         pure-expr-pointer ;; FIXME: Needs a better name.

         string->pure-expr

         pure-interp?
         pointer->pure-interp
         pure-interp->pointer
         pure-create-interp
         pure-delete-interp
         pure-switch-interp
         pure-current-interp
         )

 (define pure-dll
   (dynamic-link "libguile-sortsmillff_pure"))

 (dynamic-call "init_guile_sortsmillff_pure" pure-dll)

 (define pure-op-infix 0)
 (define pure-op-infixl 1)
 (define pure-op-infixr 2)
 (define pure-op-prefix 3)
 (define pure-op-postfix 4)
 (define pure-op-nullary 5)
 (define pure-prec-max 16777216)
 (define pure-nprec-max 167772160)

 (define pure-sym
   (let ((proc (pointer->procedure
                int32 (dynamic-func "pure_sym" pure-dll)
                `(*))))
     (lambda (s) (proc (string->pointer s "UTF-8")))))
 
 (define pure-getsym
   (let ((proc (pointer->procedure
                int32 (dynamic-func "pure_getsym" pure-dll)
                `(*))))
     (lambda (s) (proc (string->pointer s "UTF-8")))))

 (define pure-sym-pname
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_sym_pname" pure-dll)
                `(,int32))))
     (lambda (sym) (pointer->string (proc sym) -1 "UTF-8"))))
 
 (define pure-sym-other
   (pointer->procedure
    int32 (dynamic-func "pure_sym_other" pure-dll) `(,int32)))

 (define pure-sym-nprec
   (pointer->procedure
    int32 (dynamic-func "pure_sym_other" pure-dll) `(,int32)))

;;;;;;;
;;;;;;; FIXME: Actually print the Pure expression.
;;;;;;;
 (define-wrapped-pointer-type pure-expr
   pure-expr?
   internal:pointer->pure-expr pure-expr->pointer
   (lambda (expr port)
     (format port "#<pure-expr 0x~x>"
             (pointer-address (pure-expr->pointer expr)))))

 (define pointer->pure-expr
   ;; @var{pointer->pure-expr} sets up reference counting for the Pure
   ;; garbage collector, then wraps the pointer as a @var{pure-expr}
   ;; object.
   (lambda (p)
     (internal:pointer->pure-expr (scm-pure-new p))))

 (define procedure:pure-expr->pointer
   ;; Wrap the syntax transformer @var{pure-expr->pointer} in a
   ;; procedure, so C code can use it.
   (lambda (x) (pure-expr->pointer x)))

 (define pure-symbol
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_symbol" pure-dll)
                `(,int32))))
     (compose pointer->pure-expr proc)))

 ;;
 ;; FIXME: Rewrite this in C so it is not weighted down with
 ;; bytevectors.
 ;;
 (define pure-symbolx
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_symbolx" pure-dll)
                `(,int32 *))))
     (lambda (sym)
       (let* ((pure-exception (make-bytevector (sizeof '*)))
              (e (bytevector->pointer pure-exception))
              (result (proc sym e)))
         (values (pointer->pure-expr result)
                 (pointer->pure-expr (dereference-pointer e)))))))

 (define pure-quoted-symbol
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_quoted_symbol" pure-dll)
                `(,int32))))
     (compose pointer->pure-expr proc)))

 (define number->pure-expr
   (lambda (n)
     (cond
      ((inexact? n) (if (real? n)
                        (inexact->pure-expr n)
                        (complex->pure-expr n)))
      ((integer? n) (integer->pure-expr n))
      ((rational? n) (rational->pure-expr n))
      (else (error 'number->pure-expr
                   (_ "not a number") x)))))

 (define pure-expr->number
   (lambda (x)
     (cond
      ((pure-expr->small-integer-or-f x))
      ((pure-expr->inexact-or-f x))
      ((pure-expr->big-integer-or-f x))
      ((pure-expr->rational-or-f x))
      ((pure-expr->complex-or-f x))
      (else
       (error 'pure-expr->number
              (_ "the Pure expression is not a number")
              x)))))

 (define pure-expr-is-number?
   (lambda (x)
     (cond
      ((pure-expr-is-integer? x) #t)
      ((pure-expr-is-inexact? x) #t)
      ((pure-expr-is-rational? x) #t)
      ((pure-expr-is-complex? x) #t)
      (else #f))))

 (define integer->pure-expr
   (lambda (n)
     (if (and (<= -2147483648 n) (<= n 2147483647))
         (small-integer->pure-expr n)
         (big-integer->pure-expr n))))

 (define small-integer->pure-expr
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_int" pure-dll)
                `(,int32))))
     (compose pointer->pure-expr proc)))

 (define pure-expr->integer
   (lambda (x)
     (cond
      ((pure-expr->small-integer-or-f x))
      ((pure-expr->big-integer-or-f x))
      (else
       (error
        'pure-expr->integer
        (_ "the Pure expression is not an integer")
        x)))))

 (define pure-expr->small-integer
   (lambda (x)
     (cond
      ((pure-expr->small-integer-or-f x))
      (else
       (error
        'pure-expr->small-integer
        (_ "the Pure expression is not an integer in the range -2147483648 to 2147483647")
        x)))))

 (define pure-expr->big-integer
   (lambda (x)
     (cond
      ((pure-expr->big-integer-or-f x))
      (else
       (error
        'pure-expr->big-integer
        (_ "the Pure expression is not an integer outside the range -2147483648 to 2147483647")
        x)))))

 (define pure-expr-is-integer?
   (lambda (n)
     (cond
      ((pure-expr-is-small-integer? n) #t)
      ((pure-expr-is-big-integer? n) #t)
      (else #f))))

 (define pure-expr-is-small-integer?
   (compose not not pure-expr->small-integer-or-f))

 (define pure-expr-is-big-integer?
   (compose not not pure-expr->big-integer-or-f))

 (define pure-expr->rational
   (lambda (x)
     (cond
      ((pure-expr->rational-or-f x))
      (else
       (error
        'pure-expr->rational
        (_ "the Pure expression is not a rational number")
        x)))))

 (define pure-expr-is-rational?
   (compose not not pure-expr->rational-or-f))

 (define inexact->pure-expr
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_double" pure-dll)
                `(,double))))
     (compose pointer->pure-expr proc)))

 (define-syntax flonum->pure-expr
   (identifier-syntax inexact->pure-expr))

 (define pure-expr->inexact
   (lambda (x)
     (cond
      ((pure-expr->inexact-or-f x))
      (else
       (error
        'pure-expr->inexact
        (_ "the Pure expression is not a floating point number")
        x)))))

 (define-syntax pure-expr->flonum
   (identifier-syntax pure-expr->inexact))

 (define pure-expr-is-inexact?
   (compose not not pure-expr->inexact-or-f))

 (define-syntax pure-expr-is-flonum?
   (identifier-syntax pure-expr-is-inexact?))

 (define pure-expr->complex
   (lambda (x)
     (cond
      ((pure-expr->complex-or-f x))
      (else
       (error 'pure-expr->complex
              (_ "the Pure expression is not a complex number")
              x)))))

 (define pure-expr-is-complex?
   (compose not not pure-expr->complex-or-f))

 (define pointer->pointer-pure-expr
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_pointer" pure-dll)
                `(*))))
     (compose pointer->pure-expr proc)))

 (define pointer-pure-expr->pointer
   (lambda (x)
     (cond
      ((pointer-pure-expr->pointer-or-f x))
      (else
       (error 'pure-expr->complex
              (_ "the Pure expression is not a pointer")
              x)))))

 (define pure-expr-pointer
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_expr_pointer" pure-dll)
                `())))
     (lambda () (pointer->pure-expr (proc)))))


 (define string->pure-expr
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_string_dup" pure-dll)
                `(*))))
     (lambda (s)
       (pointer->pure-expr (proc (string->pointer s "UTF-8"))))))


 (define-wrapped-pointer-type pure-interp
   pure-interp? pointer->pure-interp pure-interp->pointer
   (lambda (interp port)
     (format port "#<pure-interp 0x~x>"
             (pointer-address (pure-interp->pointer interp)))))

 (define pure-create-interp
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_create_interp" pure-dll)
                `(,int *))))
     (lambda (args)
       (let ((argc (length args))
             (argv (string-list->argv args)))
         (pointer->pure-interp
          (proc argc (bytevector->pointer argv)))))))

 (define pure-delete-interp
   (let ((proc (pointer->procedure
                void (dynamic-func "pure_delete_interp" pure-dll)
                `(*))))
     (compose proc pure-interp->pointer)))

 (define pure-switch-interp
   (let ((proc (pointer->procedure
                void (dynamic-func "pure_switch_interp" pure-dll)
                `(*))))
     (compose proc pure-interp->pointer)))

 (define pure-current-interp
   (let ((proc (pointer->procedure
                '* (dynamic-func "pure_current_interp" pure-dll)
                `())))
     (compose pointer->pure-interp proc)))

 ;; FIXME: This could be useful more generally.
 (define (string-list->argv args)
   (let* ((n (length args))
          (pointer-size (sizeof '*))
          (num-bytes (* pointer-size (+ 1 n)))
          (argv (make-bytevector num-bytes 0)))
     (for-each
      (match-lambda
       ((i s) (bytevector-pointer-set! argv (* i pointer-size)
                                       (string->pointer s))))
      (zip (iota n) args))
     argv
     ))

 ;; FIXME: Put this somewhere reusable.
 (define-syntax bytevector-pointer-set!
   (lambda (x)
     (unless (or (= 4 (sizeof '*)) (= 8 (sizeof '*)))
       (error 'bytevector-pointer-set!
              "cannot handle pointer sizes other than 4 or 8"
              (sizeof '*)))
     (syntax-case x ()
       ((_ bv offset p)
        (case (sizeof '*)
          ((4) #'(bytevector-u32-native-set! bv offset (pointer-address p)))
          ((8) #'(bytevector-u64-native-set! bv offset (pointer-address p)))
          )))))

 ) ;; end of if-fontforge-has-pure-api
