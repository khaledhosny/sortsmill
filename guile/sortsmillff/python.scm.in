;; -*- mode: scheme; geiser-scheme-implementation: guile; coding: utf-8 -*-

;; Copyright (C) 2012 Barry Schwartz
;; 
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3 of the License, or
;; (at your option) any later version.
;; 
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, see <http://www.gnu.org/licenses/>.

(define-module (sortsmillff python))

(import (sortsmillff i18n)
        (sortsmillff strings)
        (rnrs)
        (only (srfi :26) cut)
        (system foreign)
        (ice-9 match))

(export if-fontforge-has-python-api)

(re-export enable-hash-guillemet-strings
           disable-hash-guillemet-strings)

(define-syntax if-fontforge-has-python-api
  (lambda (x)
    (match '@i_do_have_python_scripting@
      ('yes
       (syntax-case x ()
         ((_ e e* ...) #'(begin e e* ...))))
      ('no
       (syntax-case x ()
         ((_ _ _ ...) #'*unspecified*))))))

(if-fontforge-has-python-api

 (export python-dll

         py-initialize
         py-finalize

         make-python-error
         python-error?
         pyerr-type
         condition-pyerr-type
         pyerr-value
         condition-pyerr-value
         pyerr-traceback
         condition-pyerr-traceback

         pyobject?
         pointer->pyobject
         borrowed-pointer->pyobject
         pyobject->pointer

         ;; ‘pyguile’ is an opaque representation of Guile objects in
         ;; Python.
         scm->pyguile
         pyguile->scm
         pyguile?

         ;; scm->pyobject is like scm->pyguile, but passes pyobjects
         ;; unaltered. Other objects are converted to pyguile.
         scm->pyobject

         pair->pytuple
         list->pytuple
         list->pylist
         alist->python-alist
         python-alist->pydict
         alist->pydict
         make-pytuple
         make-pylist
         make-pydict

         pytuple->list
         pylist->list

         pytuple?
         pylist?

         pytuple-map
         pylist-map
         
         pyindexed-ref
         pyindexed-set!

         py-none ;; This is a function, not a constant.
         pynone?

         py-false ;; This is a function, not a constant.
         py-true  ;; This is a function, not a constant.
         py-not
         py-not-not ;; Use this to convert a Python value to a pybool.
         boolean->pybool
         pybool->boolean
         pybool?

         integer->pyint
         integer->pylong
         integer->pympz
         pyint->integer
         pylong->integer
         pympz->integer
         pylong->pympz
         pympz->pylong
         pyint?
         pylong?
         pympz?

         pointer->pylong ;; Big integers to represent addresses.
         pylong->pointer

         string->pystring ;; Converts to a unicode object.
         pystring->string ;; Converts from a unicode or UTF-8-encoded bytes object.
         pyunicode?
         pybytes?
         pystring?

         py-repr
         py-str
         py-name
         py-dict

         procedure->pycallable
         pycallable?

         pyapply
         pyexec
         pyexec-file-name
         pyimport
         pymodule-get-file-name
         pyeval
         current-pymodule
         )

 (define python-dll
   (dynamic-link "libguile-sortsmillff_python"))

 (dynamic-call "init_guile_sortsmillff_python" python-dll)

 (define py-initialize
   (pointer->procedure
    void (dynamic-func "Py_Initialize" python-dll) `()))

 (define py-finalize
   (pointer->procedure
    void (dynamic-func "Py_Finalize" python-dll) `()))

 (define-condition-type &python-error &error
   make-python-error python-error?
   (pyerr-type condition-pyerr-type)
   (pyerr-value condition-pyerr-value)
   (pyerr-traceback condition-pyerr-traceback))

 (define-wrapped-pointer-type pyobject
   pyobject?
   private:pointer->pyobject private:pyobject->pointer
   (lambda (obj port)
     (let ([repr (pystring->string (py-repr obj))]
           [str  (pystring->string (py-str obj))])
       (if (string=? repr str)
           (format port "#<pyobject repr:~a 0x~x>" repr
                   (pointer-address (pyobject->pointer obj)))
           (format port "#<pyobject repr:~a str:~s 0x~x>" repr str
                   (pointer-address (pyobject->pointer obj)))))))

 (define (pointer->pyobject p)
   (private:pointer->pyobject (grab-pyobject-reference p)))

 (define (borrowed-pointer->pyobject p)
   (private:pointer->pyobject (grab-borrowed-pyobject-reference p)))

 (define (pyobject->pointer obj)
   (unless (pyobject? obj)
     (assertion-violation 'pyobject->pointer (_ "expected a Python object") obj))
   (private:pyobject->pointer obj))

 (define procedure:pyobject?
   ;; Wrap the syntax transformer @var{pyobject?} in a
   ;; procedure, so C code can use it.
   (lambda (obj) (pyobject? obj)))

 (define (pair->pytuple pair)
   (list->pytuple (list (car pair) (cdr pair))))

 (define (make-pytuple . elements)
   (list->pytuple elements))

 (define (make-pylist . elements)
   (list->pylist elements))

 (define (make-pydict . key-value-pairs)
   (alist->pydict key-value-pairs))

 ;; These could ‘easily’ be re-implemented in C if necessary for
 ;; performance.
 (define pytuple-map (compose list->pytuple map pytuple->list))
 (define pylist-map (compose list->pylist map pylist->list))

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 (eval-when
  (compile eval load)
  [define (guile-python-pyx-func func-name)
    (dynamic-func func-name
                  (dynamic-link (pymodule-get-file-name
                                 (guile-python-pyx-pymodule))))] )

 (define-syntax define-guile-python-pyx-procedure
   (lambda (x)
     (syntax-case x ()
       [(_ return-type c-func arg-types)
        (let* ([my-fluid
                (datum->syntax
                 x (make-symbol
                    (string-append "*" (syntax->datum #'c-func) "*")))]
               [get-my-proc
                (datum->syntax
                 x (string->symbol (syntax->datum #'c-func)))])
          #`(begin
              ;; Thread local storage for the procedure, once we have
              ;; created it.
              (define #,my-fluid (make-fluid #f))

              (define #,get-my-proc
                (lambda ()
                  (let ((my-proc (fluid-ref #,my-fluid)))
                    (if my-proc my-proc
                        [let ((new-proc
                               [pointer->procedure return-type
                                                   (guile-python-pyx-func c-func)
                                                   arg-types]))
                          (fluid-set! #,my-fluid new-proc)
                          new-proc] ))))))] )))

 (define-syntax define-py-to-py-filter
   (lambda (x)
     (syntax-case x ()
       [(_ filter-name c-func)
        #`(define (filter-name obj)
            (cond
             [(pyobject? obj)
              (let ((result ((c-func) (pyobject->pointer obj))))
                (if (null-pointer? result)
                    (py-failure (quote c-func) (list obj))
                    (pointer->pyobject result)))]
             [else
              (assertion-failure (quote filter-name)
                                 (_ "expected a Python object") obj)] ))]
       )))

 (define-guile-python-pyx-procedure '* "__c_pyguile_make" '(*))
 (define-guile-python-pyx-procedure '* "__c_pyguile_address" '(*))
 (define-guile-python-pyx-procedure '* "__pyguile_check" '(*))
 (define-guile-python-pyx-procedure '* "__exec_python" '(*))
 (define-guile-python-pyx-procedure '* "__exec_python_file_name" '(*))
 (define-guile-python-pyx-procedure '* "__c_py_wrap_function" '(*))
 (define-guile-python-pyx-procedure '* "__apply_python_callable" '(* * *))
 (define-guile-python-pyx-procedure '* "__py_raise_guile_exception" '(*))
 (define-guile-python-pyx-procedure '* "__py_exception_description" '(*))
 (define-guile-python-pyx-procedure '* "__c_string_to_python_string" '(*))
 (define-guile-python-pyx-procedure '* "__python_string_to_c_string" '(*))
 (define-guile-python-pyx-procedure '* "__c_eval_python" '(*))
 (define-guile-python-pyx-procedure '* "__current_python_module" '())
 (define-guile-python-pyx-procedure '* "__pylong_to_pympz" '(*))
 (define-guile-python-pyx-procedure '* "__pympz_to_pylong" '(*))
 (define-guile-python-pyx-procedure '* "__is_pympz" '(*))
 (define-guile-python-pyx-procedure '* "__py_repr" '(*))
 (define-guile-python-pyx-procedure '* "__py_str" '(*))
 (define-guile-python-pyx-procedure '* "__py_name" '(*))
 (define-guile-python-pyx-procedure '* "__py_dict" '(*))
 (define-guile-python-pyx-procedure '* "__pyindexed_ref" '(*))
 (define-guile-python-pyx-procedure '* "__pyindexed_set" '(*))
 (define-guile-python-pyx-procedure '* "__python_alist_to_pydict" '(*))

 (define-py-to-py-filter pyguile?-base __pyguile_check)
 (define-py-to-py-filter pyexec-base __exec_python)
 (define-py-to-py-filter pyexec-file-name-base __exec_python_file_name)
 (define-py-to-py-filter py-raise-guile-exception __py_raise_guile_exception)
 (define-py-to-py-filter py-exception-description-base __py_exception_description)
 (define-py-to-py-filter pylong->pympz __pylong_to_pympz)
 (define-py-to-py-filter pympz->pylong __pympz_to_pylong)
 (define-py-to-py-filter py-repr __py_repr)
 (define-py-to-py-filter py-str __py_str)
 (define-py-to-py-filter py-name __py_name)
 (define-py-to-py-filter py-dict __py_dict)
 (define-py-to-py-filter pyindexed-ref-core __pyindexed_ref)
 (define-py-to-py-filter pyindexed-set!-core __pyindexed_set)
 (define-py-to-py-filter python-alist->pydict __python_alist_to_pydict)

 (define (procedure->pycallable proc)
   (let* ([wrapped-proc
           (lambda (args)
             (pyobject->pointer (apply proc (pytuple->list
                                             (pointer->pyobject args)))))]
          [func (procedure->pointer '* wrapped-proc '(*))])
     (pointer->pyobject ((__c_py_wrap_function) func))))

;;;;;
;;;;; This version that catches Guile exceptions and wraps them in
;;;;; Python exceptions seems not to be worth the trouble.
;;;;;
;;; (define (procedure->pycallable proc)
;;;   (let* ([wrapped-proc
;;;           (lambda (args)
;;;             (catch #t (lambda ()
;;;                         (pyobject->pointer
;;;                          (apply proc (pytuple->list (pointer->pyobject args)))))
;;;               pycallable-catch-handler))]
;;;          [func (procedure->pointer '* wrapped-proc '(*))])
;;;     (pointer->pyobject ((__c_py_wrap_function) func))))

 (define (pycallable-catch-handler key . args)
   (let ([py-key (string->pystring (symbol->string key))]
         [py-args (list->pytuple (map scm->pyguile args))])
     (py-raise-guile-exception (make-pytuple py-key py-args))))

 (define pyapply
   (case-lambda
     [(func args) (pyapply func args (py-none))]
     [(func args keyword-args)
      (cond
       [(not (pyobject? args)) (pyapply func (list->pytuple args) keyword-args)]
       [(not (pyobject? keyword-args)) (pyapply func args
                                                (alist->pydict keyword-args))]
       [else
        (unless (pycallable? func)
          (assertion-failure 'pyapply (_ "expected a Python callable") func))
        (pointer->pyobject ((__apply_python_callable)
                            (pyobject->pointer func)
                            (pyobject->pointer args) 
                            (pyobject->pointer keyword-args)))] )] ))

 (define (scm->pyguile obj)
   (pointer->pyobject ((__c_pyguile_make) (scm->pointer obj))))

 (define (scm->pyobject obj)
   (cond [(pyobject? obj) obj]
         [else (pointer->pyobject ((__c_pyguile_make) (scm->pointer obj)))]))

 (define (pyguile->scm obj)
   (cond [(pyguile? obj)
          (pointer->scm ((__c_pyguile_address) (pyobject->pointer obj)))]
         [else (assertion-violation 'pyguile->scm
                                    (_ "expected a pyguile object")
                                    obj)]))

 (define (pyguile? obj)
   (if (pyobject? obj) (pyguile?-base obj) #f))

 (set-exception-printer!
  'python-exception
  (lambda (port key args default-printer)
    (match args
      [[who exc-info . rest]
       (when who (format port "In procedure ~a:\n" who))
       (format port "~a" (py-exception-description exc-info))]
      [_ (default-printer)] )))

 (define (py-exception-description exc-info)
   (apply string-append
          "ERROR: Python exception:\n"
          (map pystring->string
               (pylist->list (py-exception-description-base exc-info)))))

 (define (pyexec s)
   (cond
    [[or (string? s) (pystring? s)] (pyexec-base (string->pystring s))]
    [else (string-or-pystring-failure 'pyexec s)]))

 (define (pyexec-file-name file-name)
   (cond
    [[or (string? file-name) (pystring? file-name)]
     (pyexec-file-name-base (string->pystring file-name))]
    [else (string-or-pystring-failure 'pyexec-file-name file-name)]))

 (define integer->pylong (compose pympz->pylong integer->pympz))
 (define pylong->integer (compose pympz->integer pylong->pympz))

 (define (pyindexed-ref obj i)
   (assert (pyobject? obj))
   (pyindexed-ref-core (list->pytuple (list obj i))))

 (define (pyindexed-set! obj i v)
   (assert (pyobject? obj))
   (pyindexed-set!-core (list->pytuple (list obj i v))))

 ;; As a convenience, string->pystring accepts pystrings and returns
 ;; them unmodified.
 (define string->pystring
   (match-lambda
    [(? string? s) (pointer->pyobject
                    ((__c_string_to_python_string) (string->pointer s)))]
    [(? pystring? s) s]
    [other (string-or-pystring-failure 'string->pystring other)] ))

 ;; As a convenience, pystring->string accepts Scheme strings and
 ;; returns them unmodified.
 (define pystring->string
   (match-lambda
    [(? pystring? s) (pointer->string
                      ((__python_string_to_c_string) (pyobject->pointer s)))]
    [(? string? s) s]
    [other (string-or-pystring-failure 'pystring->string other)] ))

 (define pyeval
   (match-lambda
    [(? string? s) (pointer->pyobject ((__c_eval_python) (string->pointer s)))]
    [(? pystring? s) (pyeval (pystring->string s))]
    [other (string-or-pystring-failure 'pyeval other)] ))

 (define (string-or-pystring-failure who obj)
   (assertion-failure who (_ "expected a string or Python string") obj))

 (define (current-pymodule)
   (pointer->pyobject ((__current_python_module))))

 (define (alist->python-alist alist)
   (list->pylist (map pair->pytuple alist)))

 (define alist->pydict
   (compose python-alist->pydict alist->python-alist))

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 ) ;; end of if-fontforge-has-python-api
